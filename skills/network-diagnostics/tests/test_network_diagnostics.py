#!/usr/bin/env python3
"""
Unit tests for network_diagnostics.py parsers.

Uses unittest.mock.patch to mock subprocess.run, testing parser logic
without requiring actual network commands.
"""

import json
import os
import subprocess
import sys
import unittest
from unittest.mock import patch

# Add parent scripts dir to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "scripts"))

from network_diagnostics import (
    ConnectionCollector,
    ConnectionInfo,
    HttpTimingTester,
    PingResult,
    PingTester,
    PlatformDetector,
    SpeedTester,
    TracerouteHop,
    TracerouteTester,
    hex_netmask_to_cidr,
)

# =============================================================================
# Test Fixtures - Platform-specific command outputs
# =============================================================================

MACOS_PING_OUTPUT = """\
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: icmp_seq=0 ttl=118 time=4.123 ms
64 bytes from 8.8.8.8: icmp_seq=1 ttl=118 time=3.987 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=118 time=4.256 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=118 time=5.012 ms
64 bytes from 8.8.8.8: icmp_seq=4 ttl=118 time=4.567 ms

--- 8.8.8.8 ping statistics ---
5 packets transmitted, 5 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 3.987/4.389/5.012/0.365 ms
"""

LINUX_PING_OUTPUT = """\
PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=118 time=4.12 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=118 time=3.98 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=118 time=4.25 ms
64 bytes from 8.8.8.8: icmp_seq=4 ttl=118 time=5.01 ms
64 bytes from 8.8.8.8: icmp_seq=5 ttl=118 time=4.57 ms

--- 8.8.8.8 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4006ms
rtt min/avg/max/mdev = 3.980/4.386/5.010/0.365 ms
"""

PING_PACKET_LOSS_OUTPUT = """\
PING 10.0.0.99 (10.0.0.99): 56 data bytes
64 bytes from 10.0.0.99: icmp_seq=0 ttl=64 time=1.234 ms
Request timeout for icmp_seq 1
64 bytes from 10.0.0.99: icmp_seq=2 ttl=64 time=2.345 ms
Request timeout for icmp_seq 3
64 bytes from 10.0.0.99: icmp_seq=4 ttl=64 time=1.567 ms

--- 10.0.0.99 ping statistics ---
5 packets transmitted, 3 packets received, 40.0% packet loss
round-trip min/avg/max/stddev = 1.234/1.715/2.345/0.469 ms
"""

PING_100_LOSS_OUTPUT = """\
PING 192.168.99.99 (192.168.99.99): 56 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
Request timeout for icmp_seq 2

--- 192.168.99.99 ping statistics ---
3 packets transmitted, 0 packets received, 100.0% packet loss
"""

TRACEROUTE_OUTPUT = """\
traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets
 1  gateway (192.168.1.1)  1.234 ms  1.456 ms  1.678 ms
 2  10.0.0.1 (10.0.0.1)  5.123 ms  5.234 ms  5.345 ms
 3  * * *
 4  72.14.215.81 (72.14.215.81)  8.901 ms  9.012 ms  9.123 ms
 5  dns.google (8.8.8.8)  10.234 ms  10.345 ms  10.456 ms
"""

TRACEROUTE_SINGLE_RTT_OUTPUT = """\
traceroute to 1.1.1.1 (1.1.1.1), 30 hops max, 60 byte packets
 1  gateway (192.168.1.1)  1.234 ms  1.456 ms  1.678 ms
 2  * * *
 3  one.one.one.one (1.1.1.1)  5.678 ms  5.789 ms  5.890 ms
"""

MACOS_IFCONFIG_OUTPUT = """\
en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
\tether aa:bb:cc:dd:ee:ff
\tinet6 fe80::aede:48ff:fe00:1122%en0 prefixlen 64 secured scopeid 0x6
\tinet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
\tnd6 options=201<PERFORMNUD,DAD>
\tmedia: autoselect
\tstatus: active
"""

LINUX_IP_ADDR_OUTPUT = """\
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether aa:bb:cc:dd:ee:ff brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic eth0
       valid_lft 86399sec preferred_lft 86399sec
    inet6 fe80::a8bb:ccff:fedd:eeff/64 scope link
       valid_lft forever preferred_lft forever
"""

LINUX_IFCONFIG_OUTPUT = """\
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::a8bb:ccff:fedd:eeff  prefixlen 64  scopeid 0x20<link>
        ether aa:bb:cc:dd:ee:ff  txqueuelen 1000  (Ethernet)
"""

MACOS_SCUTIL_DNS_OUTPUT = """\
DNS configuration

resolver #1
  search domain[0] : example.com
  nameserver[0] : 192.168.1.1
  nameserver[1] : 8.8.8.8
  if_index : 6 (en0)
  flags    : Request A records
  reach    : 0x00020002 (Reachable,Directly Reachable Address)

resolver #2
  domain   : local
  options  : mdns
  timeout  : 5
  flags    : Request A records
  reach    : 0x00000000 (Not Reachable)
  order    : 300000
"""

RESOLV_CONF = """\
# Generated by NetworkManager
nameserver 192.168.1.1
nameserver 8.8.8.8
"""

MACOS_NETSTAT_GATEWAY = """\
Routing tables

Internet:
Destination        Gateway            Flags        Netif Expire
default            192.168.1.1        UGScg          en0
"""

LINUX_IP_ROUTE_OUTPUT = """\
default via 192.168.1.1 dev eth0 proto dhcp metric 100
192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100 metric 100
"""

LINUX_ROUTE_N_OUTPUT = """\
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.1.1     0.0.0.0         UG    100    0        0 eth0
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
"""

MACOS_ROUTE_GET_DEFAULT = """\
   route to: default
destination: default
       mask: default
    gateway: 192.168.1.1
  interface: en0
      flags: <UP,GATEWAY,DONE,STATIC,PRCLONING,AUTOCONF>
 recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire
       0         0         0         0         0         0      1500         0
"""

MACOS_NETWORKSETUP_OUTPUT = """\
Hardware Port: Wi-Fi
Device: en0
Ethernet Address: aa:bb:cc:dd:ee:ff

Hardware Port: Bluetooth PAN
Device: en3
Ethernet Address: 11:22:33:44:55:66

Hardware Port: Thunderbolt Ethernet
Device: en1
Ethernet Address: ff:ee:dd:cc:bb:aa
"""

CURL_TIMING_OUTPUT = """\
     time_namelookup:  0.012345
        time_connect:  0.034567
     time_appconnect:  0.078901
    time_pretransfer:  0.079012
       time_redirect:  0.000000
  time_starttransfer:  0.123456
                     ----------
          time_total:  0.234567
      http_code: 200
   size_download: 1024
"""

CURL_SPEED_OUTPUT = "10485760 0.800000 13107200.000"


# =============================================================================
# Test Classes
# =============================================================================


class TestHexNetmaskToCidr(unittest.TestCase):
    """Test hex netmask to CIDR conversion."""

    def test_24_bit_mask(self):
        self.assertEqual(hex_netmask_to_cidr("0xffffff00"), 24)

    def test_16_bit_mask(self):
        self.assertEqual(hex_netmask_to_cidr("0xffff0000"), 16)

    def test_32_bit_mask(self):
        self.assertEqual(hex_netmask_to_cidr("0xffffffff"), 32)

    def test_20_bit_mask(self):
        self.assertEqual(hex_netmask_to_cidr("0xfffff000"), 20)

    def test_invalid_mask_returns_none(self):
        self.assertIsNone(hex_netmask_to_cidr("invalid"))

    def test_empty_string_returns_none(self):
        self.assertIsNone(hex_netmask_to_cidr(""))


class TestPlatformDetector(unittest.TestCase):
    """Test platform detection and command availability checks."""

    @patch("shutil.which")
    def test_check_command_exists(self, mock_which):
        mock_which.return_value = "/usr/bin/ping"
        detector = PlatformDetector()
        self.assertTrue(detector.check_command("ping"))

    @patch("shutil.which")
    def test_check_command_missing(self, mock_which):
        mock_which.return_value = None
        detector = PlatformDetector()
        self.assertFalse(detector.check_command("traceroute"))

    @patch("platform.system")
    def test_detect_macos(self, mock_system):
        mock_system.return_value = "Darwin"
        detector = PlatformDetector()
        self.assertEqual(detector.system(), "Darwin")

    @patch("platform.system")
    def test_detect_linux(self, mock_system):
        mock_system.return_value = "Linux"
        detector = PlatformDetector()
        self.assertEqual(detector.system(), "Linux")


class TestPingParser(unittest.TestCase):
    """Test parsing of ping output for macOS and Linux."""

    def setUp(self):
        self.tester = PingTester.__new__(PingTester)

    def test_parse_macos_ping_output(self):
        result = self.tester._parse_ping_output(MACOS_PING_OUTPUT, "8.8.8.8", "Google DNS", 5)
        self.assertIsNotNone(result)
        self.assertEqual(result.target, "8.8.8.8")
        self.assertEqual(result.target_name, "Google DNS")
        self.assertAlmostEqual(result.avg_ms, 4.389, places=2)
        self.assertAlmostEqual(result.min_ms, 3.987, places=2)
        self.assertAlmostEqual(result.max_ms, 5.012, places=2)
        self.assertAlmostEqual(result.stddev_ms, 0.365, places=2)
        self.assertAlmostEqual(result.packet_loss_pct, 0.0, places=1)
        self.assertEqual(result.count, 5)

    def test_parse_linux_ping_output(self):
        result = self.tester._parse_ping_output(LINUX_PING_OUTPUT, "8.8.8.8", "Google DNS", 5)
        self.assertIsNotNone(result)
        self.assertAlmostEqual(result.avg_ms, 4.386, places=2)
        self.assertAlmostEqual(result.min_ms, 3.980, places=2)
        self.assertAlmostEqual(result.max_ms, 5.010, places=2)
        self.assertAlmostEqual(result.stddev_ms, 0.365, places=2)
        self.assertAlmostEqual(result.packet_loss_pct, 0.0, places=1)

    def test_parse_packet_loss(self):
        result = self.tester._parse_ping_output(PING_PACKET_LOSS_OUTPUT, "10.0.0.99", "test", 5)
        self.assertIsNotNone(result)
        self.assertAlmostEqual(result.packet_loss_pct, 40.0, places=1)
        self.assertAlmostEqual(result.avg_ms, 1.715, places=2)

    def test_parse_100_percent_loss(self):
        result = self.tester._parse_ping_output(PING_100_LOSS_OUTPUT, "192.168.99.99", "unreachable", 3)
        self.assertIsNotNone(result)
        self.assertAlmostEqual(result.packet_loss_pct, 100.0, places=1)
        self.assertIsNone(result.avg_ms)
        self.assertIsNone(result.min_ms)
        self.assertIsNone(result.max_ms)

    @patch("subprocess.run")
    def test_ping_timeout_handling(self, mock_run):
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="ping", timeout=20)
        tester = PingTester.__new__(PingTester)
        tester._errors = []
        result = tester._run_ping("8.8.8.8", "Google DNS", 5)
        self.assertIsNone(result)
        self.assertEqual(len(tester._errors), 1)
        self.assertIn("timeout", tester._errors[0].lower())


class TestTracerouteParser(unittest.TestCase):
    """Test parsing of traceroute output."""

    def setUp(self):
        self.tester = TracerouteTester.__new__(TracerouteTester)

    def test_parse_normal_hop(self):
        result = self.tester._parse_traceroute_output(TRACEROUTE_OUTPUT, "8.8.8.8", "Google DNS")
        self.assertIsNotNone(result)
        hop1 = result.hops[0]
        self.assertEqual(hop1.hop_number, 1)
        self.assertEqual(hop1.hostname, "gateway")
        self.assertEqual(hop1.ip, "192.168.1.1")
        self.assertAlmostEqual(hop1.rtt_ms, 1.234, places=2)
        self.assertFalse(hop1.is_timeout)

    def test_parse_timeout_hop(self):
        result = self.tester._parse_traceroute_output(TRACEROUTE_OUTPUT, "8.8.8.8", "Google DNS")
        hop3 = result.hops[2]
        self.assertEqual(hop3.hop_number, 3)
        self.assertTrue(hop3.is_timeout)
        self.assertIsNone(hop3.rtt_ms)

    def test_parse_full_traceroute(self):
        result = self.tester._parse_traceroute_output(TRACEROUTE_OUTPUT, "8.8.8.8", "Google DNS")
        self.assertEqual(result.target, "8.8.8.8")
        self.assertEqual(result.target_name, "Google DNS")
        self.assertEqual(len(result.hops), 5)
        self.assertEqual(result.total_hops, 5)

    def test_parse_short_traceroute(self):
        result = self.tester._parse_traceroute_output(TRACEROUTE_SINGLE_RTT_OUTPUT, "1.1.1.1", "Cloudflare")
        self.assertEqual(len(result.hops), 3)
        self.assertTrue(result.hops[1].is_timeout)

    @patch("subprocess.run")
    def test_traceroute_timeout_handling(self, mock_run):
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="traceroute", timeout=60)
        tester = TracerouteTester.__new__(TracerouteTester)
        tester._errors = []
        result = tester._run_traceroute("8.8.8.8", "Google DNS")
        self.assertIsNone(result)
        self.assertEqual(len(tester._errors), 1)


class TestHttpTimingParser(unittest.TestCase):
    """Test parsing of curl timing output."""

    def setUp(self):
        self.tester = HttpTimingTester.__new__(HttpTimingTester)

    def test_parse_curl_timing(self):
        result = self.tester._parse_curl_output(CURL_TIMING_OUTPUT, "https://example.com")
        self.assertIsNotNone(result)
        self.assertEqual(result.url, "https://example.com")
        self.assertAlmostEqual(result.dns_ms, 12.345, places=2)
        # TCP = connect - dns
        self.assertAlmostEqual(result.tcp_ms, 22.222, places=2)
        # TLS = appconnect - connect
        self.assertAlmostEqual(result.tls_ms, 44.334, places=2)
        # TTFB = starttransfer
        self.assertAlmostEqual(result.ttfb_ms, 123.456, places=2)
        # Total
        self.assertAlmostEqual(result.total_ms, 234.567, places=2)
        self.assertEqual(result.http_code, 200)
        self.assertEqual(result.size_bytes, 1024)

    def test_tls_handshake_calculation(self):
        """TLS time = appconnect - connect."""
        result = self.tester._parse_curl_output(CURL_TIMING_OUTPUT, "https://example.com")
        expected_tls = (0.078901 - 0.034567) * 1000  # 44.334 ms
        self.assertAlmostEqual(result.tls_ms, expected_tls, places=1)

    @patch("subprocess.run")
    def test_curl_timeout_handling(self, mock_run):
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="curl", timeout=15)
        tester = HttpTimingTester.__new__(HttpTimingTester)
        tester._errors = []
        result = tester._run_http_timing("https://example.com")
        self.assertIsNone(result)
        self.assertEqual(len(tester._errors), 1)


class TestConnectionCollectorMacOS(unittest.TestCase):
    """Test connection info collection on macOS."""

    def test_parse_macos_ifconfig(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        ip, cidr, mac, mtu = collector._parse_macos_ifconfig(MACOS_IFCONFIG_OUTPUT, "en0")
        self.assertEqual(ip, "192.168.1.100")
        self.assertEqual(cidr, 24)
        self.assertEqual(mac, "aa:bb:cc:dd:ee:ff")
        self.assertEqual(mtu, 1500)

    def test_parse_scutil_dns(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        dns_servers = collector._parse_scutil_dns(MACOS_SCUTIL_DNS_OUTPUT)
        self.assertEqual(dns_servers, ["192.168.1.1", "8.8.8.8"])

    def test_parse_macos_gateway(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        gateway = collector._parse_macos_gateway(MACOS_NETSTAT_GATEWAY)
        self.assertEqual(gateway, "192.168.1.1")

    def test_parse_macos_route_get_default(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        iface = collector._parse_macos_default_interface(MACOS_ROUTE_GET_DEFAULT)
        self.assertEqual(iface, "en0")

    def test_parse_networksetup_interface_type(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        itype = collector._parse_networksetup_type(MACOS_NETWORKSETUP_OUTPUT, "en0")
        self.assertEqual(itype, "Wi-Fi")

    def test_parse_networksetup_ethernet(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        itype = collector._parse_networksetup_type(MACOS_NETWORKSETUP_OUTPUT, "en1")
        self.assertEqual(itype, "Ethernet")

    def test_parse_networksetup_usb_lan(self):
        usb_output = """\
Hardware Port: USB 10/100/1000 LAN
Device: en7
Ethernet Address: 98:fd:b4:9a:3c:b8
"""
        collector = ConnectionCollector.__new__(ConnectionCollector)
        itype = collector._parse_networksetup_type(usb_output, "en7")
        self.assertEqual(itype, "Ethernet")


class TestConnectionCollectorLinux(unittest.TestCase):
    """Test connection info collection on Linux."""

    def test_parse_linux_ip_addr(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        ip, cidr, mac, mtu = collector._parse_linux_ip_addr(LINUX_IP_ADDR_OUTPUT, "eth0")
        self.assertEqual(ip, "192.168.1.100")
        self.assertEqual(cidr, 24)
        self.assertEqual(mac, "aa:bb:cc:dd:ee:ff")
        self.assertEqual(mtu, 1500)

    def test_parse_linux_ifconfig_fallback(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        ip, cidr, mac, mtu = collector._parse_linux_ifconfig(LINUX_IFCONFIG_OUTPUT, "eth0")
        self.assertEqual(ip, "192.168.1.100")
        self.assertEqual(cidr, 24)
        self.assertEqual(mac, "aa:bb:cc:dd:ee:ff")
        self.assertEqual(mtu, 1500)

    def test_parse_resolv_conf(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        dns_servers = collector._parse_resolv_conf(RESOLV_CONF)
        self.assertEqual(dns_servers, ["192.168.1.1", "8.8.8.8"])

    def test_parse_linux_ip_route(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        gateway, iface = collector._parse_linux_ip_route(LINUX_IP_ROUTE_OUTPUT)
        self.assertEqual(gateway, "192.168.1.1")
        self.assertEqual(iface, "eth0")

    def test_parse_linux_route_n_fallback(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        gateway, iface = collector._parse_linux_route_n(LINUX_ROUTE_N_OUTPUT)
        self.assertEqual(gateway, "192.168.1.1")
        self.assertEqual(iface, "eth0")


class TestSpeedTester(unittest.TestCase):
    """Test speed test output parsing."""

    def setUp(self):
        self.tester = SpeedTester.__new__(SpeedTester)

    def test_parse_curl_speed(self):
        result = self.tester._parse_speed_output(CURL_SPEED_OUTPUT, "https://example.com/10MB.bin", "Test Server", 0.8)
        self.assertIsNotNone(result)
        self.assertEqual(result.url, "https://example.com/10MB.bin")
        self.assertEqual(result.label, "Test Server")
        self.assertGreater(result.speed_mbps, 0)

    @patch("subprocess.run")
    def test_timeout_handling(self, mock_run):
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="curl", timeout=30)
        tester = SpeedTester.__new__(SpeedTester)
        tester._errors = []
        result = tester._run_speed_test("https://example.com/10MB.bin", "Test", 30)
        self.assertIsNone(result)
        self.assertEqual(len(tester._errors), 1)


class TestTimeoutHandling(unittest.TestCase):
    """Test timeout handling across all command types."""

    @patch("subprocess.run")
    def test_ping_timeout(self, mock_run):
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="ping", timeout=20)
        tester = PingTester.__new__(PingTester)
        tester._errors = []
        result = tester._run_ping("8.8.8.8", "Google DNS", 5)
        self.assertIsNone(result)
        self.assertTrue(any("timeout" in e.lower() for e in tester._errors))

    @patch("subprocess.run")
    def test_traceroute_timeout(self, mock_run):
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="traceroute", timeout=60)
        tester = TracerouteTester.__new__(TracerouteTester)
        tester._errors = []
        result = tester._run_traceroute("8.8.8.8", "Google DNS")
        self.assertIsNone(result)
        self.assertTrue(any("timeout" in e.lower() for e in tester._errors))

    @patch("subprocess.run")
    def test_curl_timeout(self, mock_run):
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="curl", timeout=15)
        tester = HttpTimingTester.__new__(HttpTimingTester)
        tester._errors = []
        result = tester._run_http_timing("https://example.com")
        self.assertIsNone(result)
        self.assertTrue(any("timeout" in e.lower() for e in tester._errors))


class TestDiagnosticsResultSerialization(unittest.TestCase):
    """Test JSON serialization of results."""

    def test_serialize_ping_result(self):
        pr = PingResult(
            target="8.8.8.8",
            target_name="Google DNS",
            avg_ms=4.389,
            min_ms=3.987,
            max_ms=5.012,
            stddev_ms=0.365,
            packet_loss_pct=0.0,
            count=5,
        )
        d = pr.to_dict()
        self.assertEqual(d["target"], "8.8.8.8")
        self.assertEqual(d["avg_ms"], 4.389)
        j = json.dumps(d)
        self.assertIn("8.8.8.8", j)

    def test_serialize_connection_info(self):
        ci = ConnectionInfo(
            interface="en0",
            type="Wi-Fi",
            ip="192.168.1.100",
            cidr=24,
            gateway="192.168.1.1",
            dns=["8.8.8.8"],
            isp=None,
            mac="aa:bb:cc:dd:ee:ff",
            mtu=1500,
        )
        d = ci.to_dict()
        self.assertEqual(d["interface"], "en0")
        self.assertEqual(d["type"], "Wi-Fi")
        self.assertIsNone(d["isp"])

    def test_serialize_traceroute_hop(self):
        hop = TracerouteHop(hop_number=1, hostname="gateway", ip="192.168.1.1", rtt_ms=1.234, is_timeout=False)
        d = hop.to_dict()
        self.assertEqual(d["hop_number"], 1)
        self.assertFalse(d["is_timeout"])

    def test_serialize_100_loss_ping(self):
        pr = PingResult(
            target="192.168.99.99",
            target_name="unreachable",
            avg_ms=None,
            min_ms=None,
            max_ms=None,
            stddev_ms=None,
            packet_loss_pct=100.0,
            count=3,
        )
        d = pr.to_dict()
        self.assertIsNone(d["avg_ms"])
        j = json.dumps(d)
        self.assertIn('"avg_ms": null', j)


class TestNetmaskConversions(unittest.TestCase):
    """Test dotted-decimal netmask to CIDR conversion."""

    def test_parse_linux_dotted_netmask(self):
        collector = ConnectionCollector.__new__(ConnectionCollector)
        # The Linux ifconfig fallback parser should handle dotted netmask
        ip, cidr, mac, mtu = collector._parse_linux_ifconfig(LINUX_IFCONFIG_OUTPUT, "eth0")
        self.assertEqual(cidr, 24)


if __name__ == "__main__":
    unittest.main()
