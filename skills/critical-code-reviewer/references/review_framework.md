# Critical Code Review Framework

コードを批判的にレビューするためのフレームワーク。

## Core Principle: 質の高いコードとは

```
質の高いコード = 正しく動く + 読みやすい + 変更しやすい + テストしやすい
```

このレビューでは「正しく動く」は `design-implementation-reviewer` に任せ、
残りの3つの観点に集中する。

---

## 1. Review Layers（レビュー層）

### Layer 1: 設計品質（Design Quality）

**担当ペルソナ**: Veteran Engineer

```
┌─────────────────────────────────────────────┐
│ 設計品質チェックリスト                         │
├─────────────────────────────────────────────┤
│ □ 責務は適切に分離されているか？              │
│ □ 依存関係は明確か？                          │
│ □ 拡張しやすい設計か？                        │
│ □ アンチパターンはないか？                    │
│ □ 将来の変更に耐えられるか？                  │
│ □ 運用・監視の観点は考慮されているか？        │
└─────────────────────────────────────────────┘
```

**検証項目**:
- アーキテクチャパターンの適切な使用
- 依存関係の方向（上位→下位）
- 循環依存の有無
- 適切な抽象化レベル

### Layer 2: テスト容易性（Testability）

**担当ペルソナ**: TDD Expert

```
┌─────────────────────────────────────────────┐
│ テスト容易性チェックリスト                     │
├─────────────────────────────────────────────┤
│ □ 単体テストを書けるか？                      │
│ □ 依存を注入できるか？                        │
│ □ モックしやすいか？                          │
│ □ 副作用は分離されているか？                  │
│ □ テストのセットアップは単純か？              │
│ □ テスト結果は決定的か？                      │
└─────────────────────────────────────────────┘
```

**検証項目**:
- 依存性注入の使用
- インターフェースへの依存
- 外部依存の抽象化
- 時間/乱数の制御可能性

### Layer 3: 可読性（Readability）

**担当ペルソナ**: Clean Code Expert

```
┌─────────────────────────────────────────────┐
│ 可読性チェックリスト                           │
├─────────────────────────────────────────────┤
│ □ 名前が意図を表しているか？                  │
│ □ 関数は一つのことをしているか？              │
│ □ 抽象化レベルは統一されているか？            │
│ □ コードは自己文書化されているか？            │
│ □ フォーマットは一貫しているか？              │
│ □ SOLID原則に従っているか？                   │
└─────────────────────────────────────────────┘
```

**検証項目**:
- 命名規則の一貫性
- 関数/メソッドの長さ
- ネストの深さ
- コメントの質と必要性

---

## 2. Review Process（レビュープロセス）

### Step 1: 全体把握（Overview）

```
1. ファイル構成を確認
   - どのようなモジュール構成か？
   - エントリーポイントはどこか？

2. 主要なクラス/関数を特定
   - 中心となるコンポーネントは何か？
   - データの流れはどうなっているか？

3. 依存関係を把握
   - 外部ライブラリの使用
   - 内部モジュール間の依存
```

### Step 2: 詳細レビュー（Deep Dive）

```
各ペルソナの観点で詳細レビュー:

Veteran Engineer:
- 設計判断の妥当性
- アンチパターンの検出
- 運用上の問題

TDD Expert:
- テスト可能な設計か
- 依存関係の管理
- リファクタリング安全性

Clean Code Expert:
- 命名と表現力
- 関数設計
- SOLID原則
```

### Step 3: 指摘事項の整理（Consolidation）

```
1. 指摘事項をリストアップ
2. 重大度を判定
3. 重複を排除
4. 修正提案を追加
```

---

## 3. Question Framework（質問フレームワーク）

各コードに対して以下の質問を適用する。

### 設計に関する質問

```
Why? - なぜこの設計を選んだか？
├── この問題に対して最適な解決策か？
├── 他のアプローチは検討されたか？
├── トレードオフは何か？
└── 将来の変更を考慮しているか？

What if? - もし〜だったら？
├── 要件が変わったら？
├── スケールしたら？
├── 障害が発生したら？
└── 5年後も保守できるか？
```

### テスト容易性に関する質問

```
How to test? - どうやってテストする？
├── このコードを単独でテストできるか？
├── 依存をモックできるか？
├── テストのセットアップは何行必要か？
├── テストは決定的に動くか？
└── テストを書くことでAPIが改善されるか？
```

### 可読性に関する質問

```
Can I understand? - 理解できるか？
├── 名前だけで意図がわかるか？
├── 実装を読まずに関数を使えるか？
├── なぜコメントが必要なのか？
├── このコードを楽しんで読めるか？
└── 新人がこのコードを保守できるか？
```

---

## 4. Code Analysis Patterns（コード分析パターン）

### Pattern 1: 依存関係分析

```
分析対象:
- import文
- コンストラクタパラメータ
- グローバル変数アクセス
- 静的メソッド呼び出し

問題の兆候:
- 具象クラスへの直接依存
- 循環依存
- 隠れた依存（グローバル状態）
- 深い依存チェーン
```

### Pattern 2: 責務分析

```
分析対象:
- クラスのパブリックメソッド
- メソッド内の処理内容
- 依存するオブジェクトの種類

問題の兆候:
- 複数の異なる責務
- 「and」を使わないと説明できない
- 変更理由が複数ある
```

### Pattern 3: 副作用分析

```
分析対象:
- メソッド内の状態変更
- 外部システムへの書き込み
- グローバル状態の変更

問題の兆候:
- getterに副作用がある
- 予期しない状態変更
- 隠れた副作用
```

### Pattern 4: 複雑度分析

```
分析対象:
- 条件分岐の深さ
- ループのネスト
- 関数の長さ
- パラメータの数

問題の兆候:
- 深いネスト (> 3レベル)
- 長い関数 (> 20行)
- 多いパラメータ (> 3個)
- 高い循環的複雑度
```

---

## 5. Severity Classification（重大度分類）

### Critical（致命的）

```
定義: 即座に修正が必要。マージをブロックする。

例:
- バグを引き起こす設計（Nullチェック欠如等）
- リソースリーク
- 重大なセキュリティ問題
- データ整合性を損なう可能性

対応: マージ前に必ず修正
```

### Major（重大）

```
定義: 修正すべき。技術的負債になる。

例:
- God class / Long method
- テスト不可能な設計
- 重大なSOLID違反
- アンチパターンの使用

対応: このPRまたは次のスプリントで修正
```

### Minor（軽微）

```
定義: 改善推奨。品質向上に寄与。

例:
- 命名の改善
- 軽微なリファクタリング
- コメントの改善
- フォーマットの統一

対応: 時間があれば修正
```

### Info（情報）

```
定義: 提案・ベストプラクティス。必須ではない。

例:
- 代替アプローチの提案
- パフォーマンス改善の可能性
- より良いライブラリの紹介

対応: 参考情報として記録
```

---

## 6. Output Format（出力形式）

### 指摘事項フォーマット

```markdown
### [ID] [タイトル]

**重大度**: Critical / Major / Minor / Info

**検出ペルソナ**: Veteran Engineer / TDD Expert / Clean Code Expert

**該当箇所**:
```[language]
// file:line
[問題のあるコード]
```

**問題の種類**: [設計 / テスト容易性 / 可読性 / アンチパターン]

**問題の詳細**:
[何が問題か、なぜ問題かを具体的に説明]

**影響**:
[この問題が放置された場合の影響]

**推奨する修正**:
```[language]
[修正後のコード例]
```
```

### 総合評価フォーマット

```markdown
## 総合評価

**コード品質スコア**: [A / B / C / D / F]

| 観点 | 評価 | コメント |
|------|------|---------|
| 設計品質 | ⭐⭐⭐⭐☆ | [コメント] |
| テスト容易性 | ⭐⭐⭐☆☆ | [コメント] |
| 可読性 | ⭐⭐⭐⭐⭐ | [コメント] |

**マージ可否**: Ready / Conditional / Not Ready

**条件**（Conditionalの場合）:
- [必須修正事項]
```

---

## 7. Review Mindset（レビューの心構え）

### Do（すべきこと）

```
✓ 問題だけでなく解決策も提示する
✓ 具体的なコード例を示す
✓ なぜ問題かを説明する
✓ 重大度を適切に判断する
✓ 良い点も認める
✓ 学びの機会として捉える
```

### Don't（すべきでないこと）

```
✗ 個人を批判する
✗ 曖昧な指摘（「これは良くない」のみ）
✗ すべてをCriticalにする
✗ スタイルの好みを押し付ける
✗ 過度に完璧を求める
✗ コンテキストを無視する
```

### Key Principles

```
1. コードをレビューする、人をレビューしない
2. 「なぜ」を説明する
3. 建設的な提案をする
4. 重大度は厳格に、表現は穏やかに
5. 改善の方向性を示す
```
