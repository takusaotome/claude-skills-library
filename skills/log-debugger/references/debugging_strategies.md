# Debugging Strategies

## Overview

効果的なログデバッグのための戦略と思考法をまとめたリファレンスです。

---

## 1. Binary Search（二分探索法）

### 概要

問題の発生時刻を効率的に特定するために、時間範囲を半分ずつ絞り込む手法。

### プロセス

```
1. 問題が発生していない時刻（A）と発生している時刻（B）を特定
2. 中間時刻（M）のログを確認
3. Mで問題が発生している → A-M の範囲を探索
4. Mで問題が発生していない → M-B の範囲を探索
5. 範囲が十分狭くなるまで繰り返す
```

### 適用例

```
問題: 「今朝からAPIが遅い」

09:00 - 正常（前日夜の状態）
12:00 - 問題発生中

→ 10:30 を確認
10:30 - 問題発生中

→ 09:45 を確認
09:45 - 正常

→ 10:07 を確認
10:07 - 問題発生中

→ 09:56 を確認
09:56 - 正常

→ 10:01 を確認
10:01 - 問題発生開始！

結論: 10:00頃に何かが起きた
```

### 活用シーン

- 「いつから問題が発生しているか分からない」
- 「ログが大量で全部見るのは非現実的」
- 「デプロイ/設定変更の影響を特定したい」

---

## 2. Correlation Analysis（相関分析）

### 概要

複数のログソースを突合して、問題の全体像を把握する手法。

### プロセス

```
1. 関連するすべてのログソースを特定
2. タイムスタンプを統一（タイムゾーン注意）
3. 問題発生時刻を基準に各ログを確認
4. 異なるソース間の因果関係を分析
```

### 典型的なログソースの組み合わせ

| メイン | 関連ソース |
|--------|-----------|
| アプリケーションログ | DBログ、外部APIログ、メトリクス |
| Webサーバーログ | アプリログ、ロードバランサーログ |
| DBログ | アプリログ、スロークエリログ |
| Kubernetesログ | ノードログ、イベント、メトリクス |

### 相関分析テンプレート

```markdown
## Correlation Analysis

### Time: 2025-01-15 10:30:45

| Source | Observation |
|--------|-------------|
| app.log | NullPointerException at UserService.java:45 |
| nginx.log | 502 errors spike (10/min → 500/min) |
| db.log | Connection timeout errors |
| metrics | DB connection pool at 100% |

### Sequence
1. 10:30:00 - DB connection pool 飽和
2. 10:30:15 - アプリがDBタイムアウト
3. 10:30:20 - NullPointerException発生（DBレスポンス null）
4. 10:30:25 - Nginx 502 増加

### Root Cause
DBコネクションプールの枯渇が起点
```

---

## 3. Diff Analysis（差分分析）

### 概要

正常時と異常時を比較して、違いを特定する手法。

### 比較対象

| 比較項目 | 正常時 vs 異常時 |
|----------|-----------------|
| ログパターン | 出現するエラー、頻度 |
| 設定ファイル | 変更された設定 |
| デプロイバージョン | コード差分 |
| インフラ状態 | リソース使用量 |
| 外部依存 | APIバージョン、ステータス |

### 実施方法

```bash
# 正常時のログ特徴を抽出
grep -E "ERROR|WARN" normal_time.log | cut -d' ' -f4- | sort | uniq -c > normal_patterns.txt

# 異常時のログ特徴を抽出
grep -E "ERROR|WARN" abnormal_time.log | cut -d' ' -f4- | sort | uniq -c > abnormal_patterns.txt

# 差分を確認
diff normal_patterns.txt abnormal_patterns.txt
```

### 差分チェックリスト

```markdown
□ 新しく出現したエラーパターン
□ 消えたログパターン（正常な処理が止まった）
□ 頻度が急増したパターン
□ タイミングの変化（レスポンスタイム等）
□ 設定ファイルの差分
□ 依存ライブラリのバージョン
```

---

## 4. Reproduce & Isolate（再現と切り分け）

### 概要

問題を再現し、原因を切り分けていく手法。

### 再現のステップ

```
1. 問題の正確な条件を特定
   - 入力データ
   - ユーザー/アカウント
   - 環境（本番/ステージング）
   - タイミング

2. 最小再現ケースを作成
   - 不要な要素を削除
   - 問題が発生する最小条件を特定

3. 変数を一つずつ変えて検証
   - 入力データを変える
   - ユーザーを変える
   - 環境を変える
```

### 切り分けの質問

| 質問 | 目的 |
|------|------|
| 特定ユーザーだけ？ | ユーザー固有の問題か |
| 特定データだけ？ | データ起因の問題か |
| 特定時間帯だけ？ | 負荷/バッチ処理の影響か |
| 特定環境だけ？ | 環境設定の問題か |
| 特定機能だけ？ | 機能固有のバグか |
| 新規のみ？既存も？ | 最近の変更の影響か |

### 切り分けマトリクス

```markdown
| 条件 | 発生 | 非発生 |
|------|------|--------|
| User A | ✓ | |
| User B | | ✓ |
| User C | ✓ | |
| 本番環境 | ✓ | |
| ステージング | | ✓ |
| データセットX | ✓ | |
| データセットY | | ✓ |

分析: User A, C + 本番 + データセットX の組み合わせで発生
→ データセットXに問題があり、ステージングでは再現されない
→ 本番固有のデータ品質問題の可能性
```

---

## 5. Hypothesis-Driven Debugging（仮説駆動デバッグ）

### 概要

仮説を立て、検証を繰り返すことで効率的に原因を特定する手法。

### プロセス

```
1. 観察: ログから事実を収集
2. 仮説: 原因の仮説を立てる
3. 予測: 仮説が正しければ何が観察されるはずか
4. 検証: 予測を検証
5. 反復: 結果に基づいて仮説を修正
```

### 例

```markdown
## 観察
- APIレスポンスタイムが5秒以上
- DBログに「slow query」警告
- 特定のエンドポイントのみ

## 仮説1: インデックス欠如
予測: EXPLAINでフルスキャンが見られるはず
検証: EXPLAIN実行 → フルスキャン確認
結果: 仮説支持 ✓

## 仮説2: データ量増加
予測: 過去1週間でテーブルサイズ増加
検証: テーブル統計確認 → 10倍に増加
結果: 仮説支持 ✓

## 結論
データ量増加により、インデックス欠如の影響が顕在化
```

### 仮説の優先順位付け

| 優先度 | 基準 |
|--------|------|
| 高 | 検証が容易、影響が大きい、最近変更があった |
| 中 | 過去に類似事例がある、複数の証拠がある |
| 低 | 検証が困難、可能性が低い |

---

## 6. Layered Analysis（レイヤー別分析）

### 概要

システムの各レイヤーを順番に調査して、問題のあるレイヤーを特定する。

### レイヤー構造

```
┌─────────────────────────────────────┐
│         Client/Browser              │  L1
├─────────────────────────────────────┤
│         CDN/Load Balancer           │  L2
├─────────────────────────────────────┤
│         Web Server (Nginx)          │  L3
├─────────────────────────────────────┤
│         Application Server          │  L4
├─────────────────────────────────────┤
│         Database                    │  L5
├─────────────────────────────────────┤
│         Infrastructure (OS/Network) │  L6
└─────────────────────────────────────┘
```

### レイヤー別チェック

| Layer | 確認項目 | ログソース |
|-------|----------|-----------|
| L1 | ブラウザエラー、ネットワークタブ | DevTools |
| L2 | CDNキャッシュ、LBヘルスチェック | CDN/LBログ |
| L3 | リクエスト到達、レスポンスコード | nginx/apacheログ |
| L4 | 処理エラー、例外 | アプリケーションログ |
| L5 | クエリエラー、パフォーマンス | DBログ、スロークエリ |
| L6 | リソース、ネットワーク | syslog、メトリクス |

### レイヤー特定の流れ

```
1. L3 (Webサーバー) で問題が発生しているか？
   → Yes: L3以下を調査
   → No: L1-L2を調査

2. L4 (アプリ) で問題が発生しているか？
   → Yes: L4以下を調査
   → No: L3の問題

3. L5 (DB) で問題が発生しているか？
   → Yes: DBを詳細調査
   → No: L4アプリの問題
```

---

## 7. 思考法のアンチパターン

### 避けるべきパターン

| アンチパターン | 問題 | 対策 |
|---------------|------|------|
| 最初の仮説に固執 | 他の可能性を見逃す | 複数の仮説を並行検討 |
| 直近の変更を疑う | 関係ない変更に時間を浪費 | 証拠に基づいて判断 |
| ツール依存 | ツールの出力を鵜呑み | 複数の情報源で検証 |
| 深掘りしすぎ | 1つの経路に時間を浪費 | タイムボックスを設定 |
| 表面的な対処 | 再発を繰り返す | 根本原因まで追究 |

### 効果的なデバッグの心構え

1. **謙虚さ**: 自分の仮説が間違っている可能性を常に考える
2. **体系的**: 感覚ではなく、プロセスに従う
3. **記録**: 調査した内容を記録する
4. **協力**: 一人で抱え込まず、チームで取り組む
5. **時間管理**: 行き詰まったら視点を変える

---

## 8. デバッグセッションテンプレート

```markdown
# Debug Session: [問題の概要]

## 問題定義
- **症状**: [観察された症状]
- **影響**: [影響範囲]
- **発生時刻**: [いつから]
- **再現性**: [常時/間欠/特定条件]

## 調査ログ

### [HH:MM] 初期調査
- 確認したこと:
- 発見:
- 次のアクション:

### [HH:MM] 仮説検証
- 仮説:
- 検証方法:
- 結果:
- 結論:

## 根本原因
[特定された原因]

## 解決策
- 応急処置:
- 恒久対策:

## 学び
- [今後に活かせる知見]
```
